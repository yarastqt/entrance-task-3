# Задание 3

Мобилизация.Гифки – сервис для поиска гифок в перерывах между занятиями.

Сервис написан с использованием [bem-components](https://ru.bem.info/platform/libs/bem-components/5.0.0/).

Работа избранного в оффлайне реализована с помощью технологии [Service Worker](https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers).

Для поиска изображений используется [API сервиса Giphy](https://github.com/Giphy/GiphyAPI).

В браузерах, не поддерживающих сервис-воркеры, приложение так же должно корректно работать,
за исключением возможности работы в оффлайне.

## Структура проекта

  * `gifs.html` – точка входа
  * `assets` – статические файлы проекта
  * `vendor` –  статические файлы внешних библиотек
  * `service-worker.js` – скрипт сервис-воркера

Открывать `gifs.html` нужно с помощью локального веб-сервера – не как файл.
Это можно сделать с помощью встроенного в WebStorm/Idea веб-сервера, с помощью простого сервера
из состава PHP или Python. Можно воспользоваться и любым другим способом.

## Решение

1. Для начала я определил, что файл service-worker.js находится не в рут директории, а в папке assets. По этой причине область видимости сервис воркера будет ограничена лишь папкой assets, поэтому я перенес файл service-worker.js в рут директорию.
2. Далее необходимо было изменить путь для регистрации service-worker.js в файле blocks.js (строка 469). Т.к. мы перенесли service-worker.js в рут директорию, то путь стал таким: ./assets/service-worker.js -> ./service-worker.js.
3. Следующим шагом я устранил проблему с кешированием индексной страницы в файле service-worker.js, добавив в функцию needStoreForOffline ещё одно условие: cacheKey.endsWith('/'), при таком условии страница будет кешироваться даже с текстом поиска в гет параметре.
4. После чего я решил проблему с тем, что пользователь всегда получал кеш версию страницы. В файле service-worker.js я изменил поведение кеша в событии "fetch". Теперь при каждом запросе к ресурсу он берется из сети, кладется в кеш и далее отправляется клиенту. В этом случае, если запрос из сети потерпит неудачу, тогда ресурс будет взят из кеша и отправлен клиенту. При таком поведении пользователь всегда будет получать актуальную версию ресурсов.

## Дополнительное задание

Для переключения в офлайн-режим после первого запроса я сделал следующее:

1. Описал все ресурсы, необходимые для работы в офлайн-режиме:
```js
const assets = [
    '/',
    '/gifs.html',
    '/assets/blocks.js',
    '/assets/star.svg',
    '/assets/style.css',
    '/assets/templates.js',
    '/vendor/bem-components-dist-5.0.0/touch-phone/bem-components.dev.css',
    '/vendor/bem-components-dist-5.0.0/touch-phone/bem-components.dev.js',
    '/vendor/kv-keeper.js-1.0.4/kv-keeper.js'
];

```

2. Добавил функцию для пре-кеша всех статических ресурсов:
```js
function preCacheAllAssets() {
    return caches.open(CACHE_VERSION)
        .then(cache => cache.addAll(assets));
}
```
3. Изменил событие "install", добавив к пре-кешу избранных картинок пре-кеш статических ресурсов:
```js
const promise = Promise.all([
    preCacheAllAssets(),
    preCacheAllFavorites()
])
```

## Ответы на вопросы

```js
// Вопрос №1:
// зачем нужен этот вызов?
.then(() => self.skipWaiting())
// Ответ:
// Этот вызов сообщает браузеру о том, что появившийся сервис воркер
// необходимо перевести из статуса ожидания в статус активированный.
// Без этого вызова появившийся сервис воркер не будет активирован до того момента,
// пока пользователь не перезагрузит страницу.
```

```js
// Вопрос №2:
// зачем нужен этот вызов?
self.clients.claim();
// Ответ:
// Этот вызов работает совместно с self.skipWaiting().
// Данный вызов сообщает всем активным страницам, которые обрабатывает сервис воркер, о том,
// что необходимо установить данный сервис воркер в качестве активного и использовать его.
```

```js
// Вопрос №3:
// для всех ли случаев подойдёт такое построение ключа?
const cacheKey = url.origin + url.pathname;
// Ответ:
// Не для всех случаев подойдет такой ключ.
// Если у нас в имени ресурса используется какой-либо гет параметр,
// то он будет проигнорирован в таком ключе, что может повлечь за собой
// получение не актуальной версии ресурса.
```

```js
// Вопрос №4:
// зачем нужна эта цепочка вызовов?
return Promise.all(
    names.filter(name => name !== CACHE_VERSION)
        .map(name => {
            console.log('[ServiceWorker] Deleting obsolete cache:', name);
            return caches.delete(name);
        })
);
// Ответ:
// Данная цепочка вызовов нужна для того, чтобы удалить старые версии кеша.
```

```js
// Вопрос №5:
// для чего нужно клонирование?
cache.put(cacheKey, response.clone());
// Ответ:
// Клонирование объекта response необходимо для того, что его можно использовать лишь один раз.
// Но, т.к. нам нужно использовать этот объект дважды, для этого мы клонируем его:
// первый раз, чтобы положить в кеш, а второй раз - отправить клиенту.
```
